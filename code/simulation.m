classdef simulation < handle
    %This Class contains all the objects and data needed and generated for
    %a simulation. its generated by the run script.
    
    %simulation allows different modes
    %Mode: normal - This mode does a slower calculation with many wall
    %points to calculate precise agent positioning
    %Mode fasttest - This mode uses less wall points for the calculatin as
    %a result it is faster but agents can shake a little bit
    
    %Parameters:
    % -nodirections: Disables the direction line of the agents for a better
    % general overview
    
    % -nograph: Does what it says.. A non graphical mode to save simulation
    % time
    
    % -report: This parameter lets the simulation generate more detailed
    % output code
        
    
    properties
        %Iteration properties
        loops;
        
        
        %Objects
        draw;               %The drawing object
        agentSize = 200;    %Defaultwert 200 kann mit Funktion berechnet werden
        
        %Booleans
        drawGraph = 1;              %Draw graph decision boolean
        calcAdditionalReport = 0;   %Additional report boolean
        %Results
 
        spawned;                    %tracks how many agents are spawned
        result;                     %the most important Data from iteration.m
        additionalresult;           %more details aout the agents, 
                                    %calculated in simulation.m
        evaluateDistance;           %distance evaluation of the iteration.m
        evaluateTime;               %Time evaluation of the iteration.m
        
        %Properties
        agentMinRadius = 0.25;      %Minimaler Radius von einem Agent
        agentMaxSpeed;              %Used to initialize agents max speed
        
        
    end
    
    methods
        
        %Function: Constructor, constructs the sim object and reads
        %the loops from the global declarations.
        function obj = simulation()
            global LOOPS
            obj.loops = LOOPS;
            obj.spawned = zeros(2,obj.loops);
        end
    end

%-----------------------------------------------------
%Public:

    methods(Access = public)
        
        %Function: Initialize the simulation object.
        %This Function allocates memory for some arrays and initializes the
        %Agents
        %Variables:
        %   Object  - the object of this instance (matlab specific)
        function obj = init(obj)
            defineConstants(); %defne all global variables
            global SEED DENSITYUP DENSITYDOWN DELTAT
            rng(SEED);   % Set seed for random number generator
            obj.draw = drawing.empty(1,0);
            obj.draw = drawing();   %create the drawing object
            calcPossibleAgents(obj);
            obj.evaluateDistance = zeros(1,ceil((DENSITYUP+DENSITYDOWN) * DELTAT * obj.loops + 30));       
            obj.evaluateTime = zeros(1,ceil((DENSITYUP+DENSITYDOWN) * DELTAT * obj.loops + 30)); 
            
            obj.draw.agentArray = agent.empty(ceil((DENSITYUP+DENSITYDOWN) * DELTAT * obj.loops + 30) ...
                 ,0);

            
%              obj.draw.agentArray = agent.empty(obj.agentSize ...
%                  ,0);
        end
        
      
        %Function: This Function converts the input parameters to some
        %project specific booleans to enable or disable some functions or
        %to modify the speed of the simulation 
        %Variables:
        %   Object  - the object of this instance (matlab specific)
        %   mode    - the mode string to parse
        function obj = runMode(obj,mode)
                
              if(isempty(strfind(mode, '-nodirections')) == 0)
                  disp('MODE: keine Richtungsanzeige');
                  obj.draw.drawP = 0;
              end
            
              if(isempty(strfind(mode, '-nograph')) == 0)
                  disp('MODE: kein Graph');
                  obj.drawGraph = 0;
              end
              
              
              if(isempty(strfind(mode, '-report')) == 0)
                  disp('MODE: zusätzlicher report');
                  obj.calcAdditionalReport = 1;
              end
              
              if (isempty(strfind(mode, 'normal')) == 0)
                  obj.draw.particleDensity = 4;
                  obj.draw.createWall();
                disp('Running normal mode:');
                run(obj);
              elseif (isempty(strfind(mode, 'fasttest')) == 0)
                disp('Running fast mode with reduced wall points:');
                obj.draw.particleDensity = 1;
                obj.draw.createWall();
                run(obj);
              else
                disp('unknown mode');
              end
        end

            
        %Function: This function calculates more details about the agents 
        %Enable it with the parameter -report
        %Variables:
        %   Object  - the object of this instance (matlab specific)
        %   step    - the current ime step
        %Results: (saved in additionalResults)
        %row1: total distance traveled during this step
        %row2: sum of agents in the system
        function obj = additionalReport(obj, step)
            global DELTAT;
            
            sortedPrioArray = getSortedPriorityArray(getPriorityArray(obj.draw.agentArray));  
            for i = sortedPrioArray;
                way = abs(obj.draw.agentArray(i).actSpeed)*DELTAT;
                obj.additionalresult(1,step) = obj.additionalresult(1,step)+ way; %Gesammtweg aufsummieren
            end
            obj.additionalresult(2,step) = size(sortedPrioArray,2);
        end

    end
%-----------------------------------------------------
%Private:

    methods(Access = private)
        
        %Function: This function calculates the maximum of possible agents
        %for the current playfield this is used to predefine the array of
        %agents
        %Variables:
        %   Object  - the object of this instance (matlab specific)
        function obj =  calcPossibleAgents(obj) 
            obj.agentSize = floor((obj.draw.width*obj.draw.length)/...
                (3*obj.agentMinRadius^2));
        end
        
        %Function: This Function returns -1 or +1 randomly (used to
        %randomize the spawn , top or bot
        %Variables:
        %   Object  - the object of this instance (matlab specific)
        %Result:
        %   randOut -the number(-1 or +1)
        function randOut = randPrefix(obj)
           randOut = randi(2);
           if (randOut == 2)
               randOut = 1;
           else
               randOut = -1;
           end
        end
        
        
        %Function: This function fills up the agent array with new agent
        %objects. All agents have priority 0, which means they exist but are not
        %into the actual calculation.
        %Variables:
        %   Object  - the object of this instance (matlab specific)
        function obj = initialSpawn(obj)
            sze = size(obj.draw.agentArray);
        
            for i = 1:(sze)
                %For testing
                %obj.draw.length
                %obj.draw.width
                %obj.draw.agentArray(i) =  agent(0.25,obj.draw.width*rand()...
                %    ,obj.draw.length*rand(),10000,1)
                
                obj.draw.agentArray(i) = agent(0.01, 0 ,0 ,...
                    obj.agentMaxSpeed, 0);
            end

        end
        
        
        %Spawne einen neuen Agent
%         function obj = addNewAgentsToArray(obj, currentStep)
%             if (balanceProbability(obj) == 1)
%                 pfx = randPrefix(obj);
%                 if(pfx == 1)
%                     %Unten gespawnt
%                     obj.spawned(2,currentStep) = obj.spawned(currentStep) +1;
%                 else
%                     %Oben gespawnt
%                     obj.spawned(1,currentStep) = obj.spawned(currentStep) +1;
%                 end
%                 spawn(obj.draw.agentArray,pfx);
%             end
%         end


        %Function:This function spawns new agents into the simulation. it
        %uses the spawn.m to randomly get a new free position. If and where
        %the agent is spawned depends on the probabilities (See globals)
        %Variables:
        %   Object  - the object of this instance (matlab specific)
        %   currentStep -the currentStep of the simulation, used for the
        %   spawned report function
        function obj = addNewAgentsToArray(obj, currentStep)
            [probOben probUnten] = balanceProbability(obj);
            if (probOben == 1)
                obj.spawned(1,currentStep) = obj.spawned(currentStep) +1;
                spawn(obj.draw.agentArray,1);
            end
            if (probUnten == 1)
                obj.spawned(2,currentStep) = obj.spawned(currentStep) +1;
                spawn(obj.draw.agentArray,-1);
            end            
        end


        %Function: If the threshold from the globals (can be different for
        %top and bottom) is reached it returns true, otherwise false. This
        %results in a new agent trough the addNewAgentsToArray() function.
        %Variables:
        %   Object  - the object of this instance (matlab specific)
        %Result:
        %   probOben - boolean if its necessary to spawn at top
        %   probUnten - boolean if its necessary to spawn at bottom
        function [probOben probUnten] = balanceProbability(obj)
            global DENSITYUP DENSITYDOWN DELTAT
            %Genähert kommen genau im schnitt density agents
            if (rand(1) > 1-DELTAT*DENSITYUP)  
                probUnten = 1; % Von unten nach oben
            else
                probUnten = 0;
            end
            if (rand(1) > 1-DELTAT*DENSITYDOWN)  
                probOben = 1; % Von oben nach unten
            else
                probOben = 0;
            end            
        end
        
        
        %Function: Main procedure, this function contains the loop trough
        %the smulation. It calls all the other functions in the project
        %such as draw the map and add new agents or determine the direction
        %and the speed of the existing agents.
        %   Object  - the object of this instance (matlab specific)
        function obj = run(obj)
            global SPEED DELTAT;
            obj.result = zeros(2,obj.loops);
            %Speicher für additionale resultate
            if(obj.calcAdditionalReport == 1)
                obj.additionalresult = zeros(2, obj.loops);
            end
            
            initialSpawn(obj);
            
            for i = 1:obj.loops
                if(mod(i,floor(DELTAT * obj.loops)) == 0)
                    c = clock;
                    fprintf('Actual time on system: %d h %d min %d sec\n',c(4),c(5),c(6));
                    fprintf('Time elapsed: %i Seconds \n',(DELTAT*i))
                end
                [obj.result(1,i), obj.result(2,i), obj.evaluateDistance, obj.evaluateTime] = ...
                    Iteration(obj.draw.agentArray,...
                    obj.draw.wallArray, obj.evaluateDistance, obj.evaluateTime);
                
                
                addNewAgentsToArray(obj, i);
                pause(SPEED);
                
                if(obj.drawGraph == 1)
                    obj.draw.plotStep();
                end
                
                if(obj.calcAdditionalReport == 1)
                    additionalReport(obj, i);
                end
                
            end
            
            ind = find(obj.evaluateDistance == 0,1);
            if (size(ind,2) ~= 0) || (ind ~= 1)
                obj.evaluateDistance = obj.evaluateDistance(1:(ind-1));
            end
            ind = find(obj.evaluateTime == 0,1);
            if (size(ind,2) ~= 0) || (ind ~= 1)
                obj.evaluateTime = obj.evaluateTime(1:(ind-1));
            end                
           
            
        end
        
        
        
    end
    
end
