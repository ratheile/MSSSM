%Iteration

\subsubsection{General considerations}
One iteration step is carried out using the function \textit{Iteration.m}. For it to work properly, the array of all agents and all wall agents has to passed to it. All other inputs as well as all output variables are introduced for evalutation of the model and are per se not necessary for the iteration. It deals with three main tasks, the propagation of the simulation in time, the collision detection and the destruction of an agent after reaching its goal.\\
The spawning of new agents is treated in the function \textit{Spawn.m}. Both functions are called from the \textit{simulation.m} which controlls the simulation and stores all the data.

\subsubsection{Iteration step and collision detection}
This function takes four input array, although only two are critical for the success of the iteration. Those two are the arrays for all dynamic and static agents (equals wall agents). The output consists of the number of agents which disapeared during the iteration step, the distance covered by the disapeared agents as well as the time the disapeared agents had spent in the simulations.\\
At first, an index array is calculated with the indices of the dynamic agents in the given array of agents sorted according to their priority. This is done using the functions \textit{getPriorityArray.m} and \textit{getSortedPriorityArray.m}. Then a loop over the index array is carried out.\\
For every agent, the desired direction is calculated using the function \textit{logicFunction.m} explained above. Using the angle obtained by the call of \textit{logicFunction.m} und the speed given as the agent property, the new $x$- and $y$-coordiantes-to-be are determined. The path to it is then split in several substeps with the number of divisions given in the constant \texttt{PRECISIONCOLLISION}. In addition, the place where the agents stands is also included in case the agent cannot move at all.\\
For each of these positions, the distance to all other agents minus the radii is calculated yielding a distance matrix. This is done over all agents, dynamic as well as static. The last position for each other agent is left -1 as a sentinel. The distance matrix is then sorted using the matlab command \textit{sort} which leaves the most negative value for each column in the first row. The position of the first negative minimal distance indicates a collision. This position minus 1 will then be the distance the agent in question walks.\\

\noi In very rare cases, all positions in the first row of the sorted distance matrix are negative. This has the very nasty significance of an agent that could not even stand at its actual position. We reckon this has to do with some small numerical errors, as it occurs very rarely. To leave the agent at its actual position will now only result in a complete freze of two agents. It is certainly not a nice solution, but in these cases we simply deleted the faulty agent by setting its priority to 0 and reset its distance and time properties to enable the simulation to keep on running.

\subsubsection{Destruction of agents}
If an agent reaches his goal, namely the other side, it is automatically deleted inside \textit{Iteration.m}. This is simply done by setting the priority of the agent to 0. The attributes time and distance are read out before resetting and handed back to the calling function for later evaluation. After a deletion, the priority array giving all the indices of active agents is recalculated in order to avoid any influence of the deleted agent on other agents as the iteration step proceeds through the residual agents in the loop over all agents.

\subsubsection{Spawning new agents}
Spawning of one new agents is done by the function \textit{spawn.m}. Every call of \textit{spawn.m} spawns a new agent, whether the function is called at all is handled an instance higher in the simulation class. After each iteration step, namely by calling \textit{Iteration.m}, the class simulation determines whether a new agent is spawned or not.\\

\noi There are two constants determining the amount of agents spawned over a long period called \texttt{DENSITYUP} and \texttt{DENSITYDOWN}. They correspond to a density of people or, in other words, the number of people per second that should appear. As the names suggest, one is used for the number of agents spawned in the upper spawn zone while the other is used for the number of agents in the lower spawn zone. This information is then passed down to the function \textit{spawn.m} in the variable \textit{position} which can only take the values 1 or $-1$. Using our implementation, maximally one agent is spawned per iteration per side according to the following equation with the according density $\rho$ and the time step length $\Delta t$.
\begin{equation}\label{iteration1}
	p(\text{spawn}) = \left\{\begin{array}{cc}\Delta t \cdot \rho&\Delta t \cdot \rho \leq 1\\1&\Delta t \cdot \rho > 1\end{array}\right.
\end{equation}
\noi For sufficiently small values of $\Delta t$ and $\rho$, it can be in good approximation assumed that only one agent is spawned per time step. The probability of spawning two agents would go with $p^2$ which is small for the values we have chosen. Otherwise one would have to implement an additional condition which would determine at first how many agents are to be spawned with the probability for spawning $n$ agents going in principle with $p^n$.\\

\noi To spawn an agent, the first agent position in the array of agents with a priority of 0 is taken. The radius is generated using a normal distribution (\textit{randn} in matlab) with a mean of \texttt{MEANRADIUS} and a standard deviation of \texttt{STDRADIUS}. The maximal deviation possible was set to be three times the standard deviation. Should the generated radius be out of bounds, the radius generating procedure was simply repeated. A starting position in $x$-direction is then generated with an uniform random distribution over all possible starting values. A collision detection is then carried out to see whether the chosen position is possible without spawning onto another agent. If it fails, this procedure is repeated \texttt{REP} times, a constant defined at the beginning. The $y$-position is given by the dimension of the field while the velocity is determined using a normal distribution in the same way as before for the radius with the mean given by \texttt{MEANSPEED} and the standard deviation given by \texttt{STDSPEED}.\\

\noi It is possible to implement other spawn sequences than the one used for this model. If one wishes to get specific agents with certain properties, they could also be spawned directly from the simulation.
